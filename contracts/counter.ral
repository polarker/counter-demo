import "std/fungible_token_interface"

Contract Counter(
  symbol: ByteVec,
  name: ByteVec,
  totalSupply: U256,
  rewardPerReduction: U256,
  mut owner: Address,
  mut count: U256,
  @unused countDecimals: U256
) implements IFungibleToken {
  event CountIncreased(num: U256)
  event CountDecreased(num: U256, to: Address, rewardAmount: U256)

  const InvalidCaller = 0

  pub fn getSymbol() -> ByteVec {
    return symbol
  }

  pub fn getName() -> ByteVec {
    return name
  }

  pub fn getDecimals() -> U256 {
    return 18
  }

  pub fn getTotalSupply() -> U256 {
    return totalSupply
  }

  pub fn getCurrentCount() -> U256 {
    return count
  }

  @using(updateFields = true, checkExternalCaller = false)
  pub fn increase(num: U256) -> () {
    // checkCaller!(callerAddress!() == owner, InvalidCaller)
    count = count + num
    emit CountIncreased(num)
  }

  @using(updateFields = true, assetsInContract = true, preapprovedAssets = true, checkExternalCaller = false)
  pub fn decrease(num: U256, to: Address) -> () {
    // checkCaller!(callerAddress!() == owner, InvalidCaller)
    count = count - num

    let rewardAmount = num * rewardPerReduction
    transferToken!(callerAddress!(), to, ALPH, dustAmount!())
    transferTokenFromSelf!(to, selfTokenId!(), rewardAmount)

    emit CountDecreased(num, to, rewardAmount)
  }

  @using(updateFields = true)
  pub fn setOwner(newOwner: Address) -> () {
    checkCaller!(callerAddress!() == owner, InvalidCaller)
    owner = newOwner
  }
}
